minting ism_multi_sig

import { Message } from "./message.hl"

// Constants
const TOKEN_NAME_AUTH: ByteArray = #61757468 // auth
const LABEL_HYPERLANE: ByteArray = #48595045524c414e45 // HYPERLANE

// Parameters
// The verification keys whose signatures are acknowledged.
const VALIDATOR_VKEYS: []ByteArray = []ByteArray{}

// https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/main/solidity/contracts/ValidatorAnnounce.sol#L35C24-L35C30
const VALIDATOR_STORAGE_LOCATIONS: []ByteArray = []ByteArray{}

// The number of signatures needed to pass a transaction.
const THRESHOLD: Int = 0

// The recipient address where messages are posted to.
// Owners must decide to post inbound messages to a pre-defined address
// to prevent bad guys stealing auth tokens from an authentic message
// then post it with a malicious message to a dApp address, since tokens
// and datums are not directly tied together.
const RECIPIENT_ADDRESS: Address = Address::new(
  Credential::new_pubkey(PubKeyHash::new(#)), Option[StakingCredential]::None
)
// End of Parameters

// Redeemer
// https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/main/solidity/contracts/libs/CheckpointLib.sol
// "Int" is unbounded in Plutus so we use "ByteArray" for "origin"
// and "checkpoint_index" to easier handle padding.
struct RedeemerIsmMultiSig {
  // The origin domain of the checkpoint
  origin: ByteArray
  // The address of the origin mailbox
  origin_mailbox: ByteArray
  // The root of the checkpoint
  checkpoint_root: ByteArray
  // The index of the checkpoint
  checkpoint_index: ByteArray
  // The signatures signed on the hash
  signatures: []ByteArray
}

// (1) & (2) are strict and make it easier to reason about the ISM.
// We can loosen them as there are demands from dApp developers
// for more advanced integrations.
func main(redeemer: RedeemerIsmMultiSig, ctx: ScriptContext) -> Bool {
  // (0) Validate redeemers
  assert(redeemer.origin.length == 32, "invalid origin");
  assert(redeemer.origin_mailbox.length == 32, "invalid origin_mailbox");
  assert(redeemer.checkpoint_root.length == 32, "invalid checkpoint_root");
  assert(redeemer.checkpoint_index.length == 32, "invalid checkpoint_index");

  // (1) Must mint only a single auth token.
  asset_class_auth_token: AssetClass = AssetClass::new(
    ctx.get_current_minting_policy_hash(),
    TOKEN_NAME_AUTH
  );
  value_single_auth_token: Value = Value::new(asset_class_auth_token, 1);
  assert(ctx.tx.minted == value_single_auth_token, "invalid minting");

  // (2) Must produce a single valid message UTxO, which is the only
  // output that can hold an authentic token.
  authentic_outputs: []TxOutput = ctx.tx.outputs.filter((output: TxOutput) -> {
    output.value.get_safe(asset_class_auth_token) > 0
  });
  assert(authentic_outputs.length == 1, "invalid outputs");
  output: TxOutput = authentic_outputs.head;
  assert(
    output.address == RECIPIENT_ADDRESS &&
    output.value.get_assets() == value_single_auth_token,
    "invalid output"
  );

  message: Message = output.datum.switch {
    i: Inline => Message::from_data(i.data),
    else => error("Invalid message output: missing inline datum")
  };

  // (3) The submitted message is signed by the required number of "owners".
  // NOTE: We can look up faster by adding the public key to each redeemer signature.
  checkpoint_digest: ByteArray = (
    (redeemer.origin + redeemer.origin_mailbox + LABEL_HYPERLANE).blake2b() +
    redeemer.checkpoint_root +
    redeemer.checkpoint_index +
    message.id()
  ).blake2b();
  valid_signatures: []ByteArray = redeemer.signatures.filter((signature: ByteArray) -> {
    VALIDATOR_VKEYS.any((vkey: ByteArray) -> {
      vkey.verify_ecdsa_secp256k1_signature(checkpoint_digest, signature)
    })
  });
  valid_signatures.length >= THRESHOLD
}
