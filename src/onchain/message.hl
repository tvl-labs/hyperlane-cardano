module message

struct MessagePayloadMint {
  asset_class: AssetClass
  quantity: Int
  recipient_address: Address
}

// Following Hyperlane as tight as possible
// https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/main/solidity/contracts/libs/Message.sol
// "Int" is unbounded in Plutus so we use "ByteArray" to easier handle padding.
// TODO: More specific types for addresses, etc.
struct Message {
  // The version of the origin and destination Mailboxes
  version: ByteArray
  // A nonce to uniquely identify the message on its origin chain
  nonce: ByteArray
  // Domain of origin chain
  origin_domain: ByteArray
  // Address of sender as bytes32
  sender: ByteArray
  // Domain of destination chain
  destination_domain: ByteArray
  // Address of recipient on destination chain as bytes32
  recipient: ByteArray
  // Raw bytes of message body
  message: ByteArray

  func is_valid(self) -> Bool {
    self.version.length == 1 &&
    self.nonce.length == 4 &&
    self.origin_domain.length == 4 &&
    self.sender.length == 32 &&
    self.destination_domain.length == 4 &&
    self.recipient.length == 32
  }

  func id(self) -> ByteArray {
    ( self.version +
      self.nonce +
      self.origin_domain +
      self.sender +
      self.destination_domain +
      self.recipient +
      self.message
    ).blake2b()
  }

  // TODO: Support multiple token mints at once
  // Assuming minting only one asset at the moment.
  func get_mint_payload(self) -> MessagePayloadMint {
    // Skip the first 224 bytes of:
    // - 32: root chain id
    // - 32: root sender
    // - 160: offset
    raw_token_bytes: ByteArray = self.message.slice(224, self.message.length);
    quantity: Int = Int::from_big_endian(raw_token_bytes.slice(0, 32));
    asset_id_length: Int = Int::from_big_endian(raw_token_bytes.slice(32, 64));
    asset_class: AssetClass = AssetClass::new(
      MintingPolicyHash::new(raw_token_bytes.slice(64, 92)),
      raw_token_bytes.slice(92, 64 + asset_id_length) // 120 + asset_id_length - 28
    );
    recipient_address_length: Int = Int::from_big_endian(raw_token_bytes.slice(64 + asset_id_length, 96 + asset_id_length)) - 1;
    recipient_address: Address = Address::new(
      // TODO: Support validator address
      Credential::new_pubkey(PubKeyHash::new(
        raw_token_bytes.slice(97 + asset_id_length, 125 + asset_id_length)
      )),
      if (recipient_address_length > 28) {
        // TODO: Support stake validator
        Option[StakingCredential]::Some{
          StakingCredential::new_hash(StakingHash::new_stakekey(StakeKeyHash::new(
            raw_token_bytes.slice(125 + asset_id_length, 97 + asset_id_length + recipient_address_length)
          )))
        }
      } else {
        Option[StakingCredential]::None
      }
    );
    MessagePayloadMint {
      asset_class,
      quantity,
      recipient_address
    }
  }
}
