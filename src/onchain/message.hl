module message

struct MessagePayloadMint {
  token_name: ByteArray
  quantity: Int
  recipient_address: Address
}

struct MessagePayloadBurn {
  token_name: ByteArray
  quantity: Int
}

// Following Hyperlane as tight as possible
// https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/main/solidity/contracts/libs/Message.sol
// "Int" is unbounded in Plutus so we use "ByteArray" to easier handle padding.
// TODO: More specific types for addresses, etc.
struct Message {
  // The version of the origin and destination Mailboxes
  version: ByteArray
  // A nonce to uniquely identify the message on its origin chain
  nonce: ByteArray
  // Domain of origin chain
  origin_domain: ByteArray
  // Address of sender as bytes32
  // A credential in Cardano is 28 bytes (Blake2b_224),
  // We pad 4 bytes on the left:
  // 00000000: Payment credential that must sign the tx.
  // 01000000: Minting policy hash that must mint in the tx.
  sender: ByteArray
  // Domain of destination chain
  destination_domain: ByteArray
  // Address of recipient on destination chain as bytes32
  recipient: ByteArray
  // Raw bytes of message body
  message: ByteArray

  func is_valid(self) -> Bool {
    self.version.length == 1 &&
    self.nonce.length == 4 &&
    self.origin_domain.length == 4 &&
    self.sender.length == 32 &&
    self.destination_domain.length == 4 &&
    self.recipient.length == 32
  }

  func id(self) -> ByteArray {
    ( self.version +
      self.nonce +
      self.origin_domain +
      self.sender +
      self.destination_domain +
      self.recipient +
      self.message
    ).blake2b()
  }

  func get_recipient(self) -> Address {
    Address::new(
      // TODO: Support pubkey address
      Credential::new_validator(ValidatorHash::new(self.recipient.slice(4, 32))),
      // TODO: Support staking credential
      Option[StakingCredential]::None
    )
  }

  // TODO: Support multiple asset mints at once
  // Assuming minting only one asset at the moment.
  func get_mint_payload(self, hash_map: Map[ByteArray]ByteArray) -> MessagePayloadMint {
    // Skip the first 96 bytes of:
    // - 32: root chain id
    // - 32: root sender
    // - 32: offset
    raw_token_bytes: ByteArray = self.message.slice(96, self.message.length);
    recipient_address_hash: ByteArray = raw_token_bytes.slice(0, 32);
    recipient_address_raw: ByteArray = hash_map.get(recipient_address_hash);
    recipient_address: Address = Address::new(
      // TODO: Support validator address
      Credential::new_pubkey(PubKeyHash::new(recipient_address_raw.slice(1, 29))),
      if (recipient_address_raw.length > 29) {
        // TODO: Support stake validator
        Option[StakingCredential]::Some{
          StakingCredential::new_hash(StakingHash::new_stakekey(StakeKeyHash::new(
            recipient_address_raw.slice(29, 57)
          )))
        }
      } else {
        Option[StakingCredential]::None
      }
    );
    // Skip 96 more bytes of offset
    quantity: Int = Int::from_big_endian(raw_token_bytes.slice(128, 160));
    token_name_length: Int = Int::from_big_endian(raw_token_bytes.slice(160, 192));
    token_name: ByteArray = raw_token_bytes.slice(192, 192 + token_name_length);
    MessagePayloadMint {
      token_name,
      quantity,
      recipient_address
    }
  }

  // TODO: Support multiple asset burns at once
  // Assuming burning only one asset at the moment.
  func get_burn_payload(self) -> MessagePayloadBurn {
    // TODO: Truer support for ABI decode, for potentially non-empty
    // interchain liquidity hub payload, etc.

    // Skip 320 bytes of offset
    quantity: Int = Int::from_big_endian(self.message.slice(320, 352));
    token_name_length: Int = Int::from_big_endian(self.message.slice(352, 384));
    token_name: ByteArray = self.message.slice(384, 384 + token_name_length);
    MessagePayloadBurn {
      token_name,
      quantity
    }
  }
}
