module message

struct MessagePayloadMint {
  asset_class: AssetClass
  quantity: Int
  recipient_address: Address
}

// Following Hyperlane as tight as possible
// https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/main/solidity/contracts/libs/Message.sol
// "Int" is unbounded in Plutus so we use "ByteArray" to easier handle padding.
// TODO: More specific types for addresses, etc.
struct Message {
  // The version of the origin and destination Mailboxes
  version: ByteArray
  // A nonce to uniquely identify the message on its origin chain
  nonce: ByteArray
  // Domain of origin chain
  origin_domain: ByteArray
  // Address of sender as bytes32
  sender: ByteArray
  // Domain of destination chain
  destination_domain: ByteArray
  // Address of recipient on destination chain as bytes32
  recipient: ByteArray
  // Raw bytes of message body
  message: ByteArray

  func is_valid(self) -> Bool {
    self.version.length == 1 &&
    self.nonce.length == 4 &&
    self.origin_domain.length == 4 &&
    self.sender.length == 32 &&
    self.destination_domain.length == 4 &&
    self.recipient.length == 32
  }

  func id(self) -> ByteArray {
    ( self.version +
      self.nonce +
      self.origin_domain +
      self.sender +
      self.destination_domain +
      self.recipient +
      self.message
    ).blake2b()
  }

  // TODO: Support multiple token mints at once
  // Assuming minting only one asset at the moment.
  func get_mint_payload(self, hash_map: Map[ByteArray]ByteArray) -> MessagePayloadMint {
    // Skip the first 96 bytes of:
    // - 32: root chain id
    // - 32: root sender
    // - 32: offset
    raw_token_bytes: ByteArray = self.message.slice(96, self.message.length);
    recipient_address_hash: ByteArray = raw_token_bytes.slice(0, 32);
    recipient_address_raw: ByteArray = hash_map.get(recipient_address_hash);
    recipient_address: Address = Address::new(
      // TODO: Support validator address
      Credential::new_pubkey(PubKeyHash::new(recipient_address_raw.slice(1, 29))),
      if (recipient_address_raw.length > 29) {
        // TODO: Support stake validator
        Option[StakingCredential]::Some{
          StakingCredential::new_hash(StakingHash::new_stakekey(StakeKeyHash::new(
            recipient_address_raw.slice(29, 57)
          )))
        }
      } else {
        Option[StakingCredential]::None
      }
    );
    // Skip 96 more bytes of offset
    quantity: Int = Int::from_big_endian(raw_token_bytes.slice(128, 160));
    asset_id_length: Int = Int::from_big_endian(raw_token_bytes.slice(160, 192));
    asset_class: AssetClass = AssetClass::new(
      MintingPolicyHash::new(raw_token_bytes.slice(192, 220)),
      raw_token_bytes.slice(220, 192 + asset_id_length) // 220 + asset_id_length - 28
    );
    MessagePayloadMint {
      asset_class,
      quantity,
      recipient_address
    }
  }
}
