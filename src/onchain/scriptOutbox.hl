spending outbox

// TODO: Move to its own module (merkleTree.hl)
const TREE_DEPTH: Int = 32
const MAX_LEAVES: Int = 4294967295 // 2 ^ TREE_DEPTH - 1

// Trying to stay close to the Hyperlane implementation.
// https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/main/solidity/contracts/libs/Merkle.sol
struct MerkleTree {
  branches: []ByteArray
  count: Int

  func update_branches(self, i: Int, size: Int, node: ByteArray) -> []ByteArray {
    assert(i < TREE_DEPTH, "Max tree depth exceeded");
    if (size % 2 == 1) {
      self.branches.take(i) + self.branches.drop(i + 1).prepend(node)
    } else {
      update_branches(i + 1, size / 2, (self.branches.get(i) + node).blake2b())
    }
  }

  func insert(self, node: ByteArray) -> MerkleTree {
    assert(self.count < MAX_LEAVES, "The merkle tree is full");
    MerkleTree {
      branches: self.update_branches(0, self.count + 1, node),
      count: self.count + 1
    }
  }
}

struct DatumOutbox {
  merkle_tree: MerkleTree
  latest_message: ByteArray
}

// Trying to stay close to the Hyperlane implementation.
// https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/main/solidity/contracts/libs/Message.sol#L33
// "Int" is unbounded in Plutus so we use "ByteArray" to easier handle padding.
// TODO: More specific types for addresses, etc.
struct RedeemerOutbox {
  // The version of the origin and destination Mailboxes
  version: ByteArray
  // A nonce to uniquely identify the message on its origin chain
  nonce: ByteArray
  // Domain of origin chain
  // TODO: Do we hardcode or reference a UTxO instead of reading from redeemer?
  origin_domain: ByteArray
  // Address of sender as bytes32
  // TODO: Do we read from the tx instead of reading from redeemer?
  // It'd be quite weird not checking signatures of the sender.
  sender: ByteArray
  // Domain of destination chain
  destination_domain: ByteArray
  // Address of recipient on destination chain as bytes32
  recipient: ByteArray
  // NOTE: We put the message in the next datum and don't repeat it here to save bytes
}

// TODO: Authentic outboxes with clearer identities?
// TODO: Allow progressing multiple outboxes in the same tx?
func main(datum: DatumOutbox, redeemer: RedeemerOutbox, ctx: ScriptContext) -> Bool {
  // (0) Validate redeemer
  assert(redeemer.version.length == 8, "invalid version");
  assert(redeemer.nonce.length == 32, "invalid nonce");
  assert(redeemer.origin_domain.length == 32, "invalid origin_domain");
  assert(redeemer.sender.length == 32, "invalid sender");
  assert(redeemer.destination_domain.length == 32, "invalid destination_domain");
  assert(redeemer.recipient.length == 32, "invalid recipient");

  outbox_address: Address = ctx.get_current_input().output.address;

  // (1) Can consume only one outbox
  outbox_inputs: []TxInput = ctx.tx.inputs.filter((input: TxInput) -> {
    input.output.address == outbox_address
  });
  assert(outbox_inputs.length == 1, "Can only consume one outbox");

  // (2) Can produce only one outbox
  outbox_outputs: []TxOutput = ctx.tx.outputs.filter((output: TxOutput) -> {
    output.address == outbox_address
  });
  assert(outbox_outputs.length == 1, "Can only produce one outbox");

  // TODO: Add value checks here?
  // Like prevent ADA withdrawals from outboxes.
  next_datum: DatumOutbox = outbox_outputs.head.datum.switch {
    i: Inline => DatumOutbox::from_data(i.data),
    else => error("Invalid outbox output: missing inline datum")
  };

  // (3) Progress the merkle tree correctly
  message_id: ByteArray = (
    redeemer.version +
    redeemer.nonce +
    redeemer.origin_domain +
    redeemer.sender +
    redeemer.destination_domain +
    redeemer.recipient +
    next_datum.latest_message
  ).blake2b();
  next_datum.merkle_tree == datum.merkle_tree.insert(message_id)
}
