spending outbox

// TODO: Move to its own module (merkleTree.hl)
const TREE_DEPTH: Int = 32
const MAX_LEAVES: Int = 4294967295 // 2 ^ TREE_DEPTH - 1

import { Message } from "./message.hl"

// Trying to stay close to the Hyperlane implementation.
// https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/main/solidity/contracts/libs/Merkle.sol
struct MerkleTree {
  branches: []ByteArray
  count: Int

  func update_branches(self, i: Int, size: Int, node: ByteArray) -> []ByteArray {
    assert(i < TREE_DEPTH, "Max tree depth exceeded");
    if (size % 2 == 1) {
      self.branches.set(i, node)
    } else {
      self.update_branches(i + 1, size / 2, (self.branches.get(i) + node).blake2b())
    }
  }

  func insert(self, node: ByteArray) -> MerkleTree {
    assert(self.count < MAX_LEAVES, "The merkle tree is full");
    MerkleTree {
      branches: self.update_branches(0, self.count + 1, node),
      count: self.count + 1
    }
  }
}

struct DatumOutbox {
  merkle_tree: MerkleTree
  latest_message: Option[Message]
}

// TODO: Authentic outboxes with clearer identities?
// TODO: Allow progressing multiple outboxes in the same tx?
func main(datum: DatumOutbox, _, ctx: ScriptContext) -> Bool {
  current_output: TxOutput = ctx.get_current_input().output;

  // (1) Can consume only one outbox
  outbox_inputs: []TxInput = ctx.tx.inputs.filter((input: TxInput) -> {
    input.output.address == current_output.address
  });
  assert(outbox_inputs.length == 1, "Can only consume one outbox");

  // (2) Can produce only one outbox
  outbox_outputs: []TxOutput = ctx.tx.outputs.filter((output: TxOutput) -> {
    output.address == current_output.address
  });
  assert(outbox_outputs.length == 1, "Can only produce one outbox");

  outbox_output: TxOutput = outbox_outputs.head;

  // (3) Can only deposit more lovelace and not spend anything
  // This is to protect (optonal) auth tokens that identify outboxes
  assert(
    outbox_output.value.get_assets() == current_output.value.get_assets() &&
    outbox_output.value.get_lovelace() >= current_output.value.get_lovelace(),
    "Invalid value -- can only deposit more lovelace"
  );

  // TODO: Add value checks here?
  // Like prevent ADA withdrawals from outboxes.
  // (4) Validate message
  next_datum: DatumOutbox = outbox_output.datum.switch {
    i: Inline => DatumOutbox::from_data(i.data),
    else => error("Invalid outbox output: missing inline datum")
  };
  message: Message = next_datum.latest_message.unwrap();
  assert(message.is_valid(), "Invalid message");
  assert(
    Int::from_big_endian(message.nonce) == datum.merkle_tree.count,
    "Invalid nonce"
  );

  // (5) Progress the merkle tree correctly
  next_datum.merkle_tree == datum.merkle_tree.insert(message.id())

  // TODO: Validate message's sender & origin domain on-chain?
}
